package bit_manipulation;

/**
 *给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
 *
 * 示例 1:
 * 输入: 1
 * 输出: true
 * 解释: 20 = 1
 *
 * 示例 2:
 * 输入: 16
 * 输出: true
 * 解释: 24 = 16
 *
 * 示例 3:
 * 输入: 218
 * 输出: false
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/power-of-two
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @author sun. on 9/6/2019.
 */
public class PowerOfTwo {

	public boolean isPowerOfTwo(int n) {
		/**********************************************
		 * 因为2的幂次方在2进制下只有1位是1
		 * 2=10
		 * 4=100
		 * 8=1000
		 * 16=100000
		 * 256=100000000
		 *********************************************/
		//		n > 0 && (n << 30) % n == 0
		/**********************************************
		 * 负数的在计算机中二进制表示为补码(原码正常二进制表示，原码按位取反(0-1,1-0) 最后再+1)
		 * 比如 2=00000010 -2=11111110
		 * 所以如果是2的幂 00000010&11111110=00000010
		 *********************************************/
		//		n > 0 && (n & -n) == n
		/**********************************************
		 * 因为2的幂次方在2进制下只有1位是1,如果是2的幂 n-1 二进制数，就是左边都是0，右边按位取反 相当于从右往左按位取反，直到遇到1
		 * 比如
		 * 8=00001000
		 * 7=00000111
		 * 所以如果是2的幂 n&n-1=0
		 *********************************************/
		return n > 0 && (n & (n - 1)) == 0;
	}

	public static void main(String[] args) {
		int input = 8;
		int input2 = 7;
		System.out.println(new PowerOfTwo().isPowerOfTwo(input));
		System.out.println(new PowerOfTwo().isPowerOfTwo(input2));

	}
}
